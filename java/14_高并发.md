# volatile关键字
* 内存的可见性
```
在多线程中JVM虚拟机为了优化和提高效率，为每一个线程都提供了一个单独的缓存空间；
所有变量值都存储在堆中的主内存中，每个线程都会保存使用到的变量副本到本地缓存空间。

JVM规定：
a.线程对共享变量的所有操作都必须在自己的缓存空间中进行，不能直接操作主内存中的共享变量。
b.不同线程间无法直接访问其他线程缓存空间中的变量，线程间变量值的传递需要通过主内存来完成。

```
* 指令重排序
```
重排序发生在两个阶段：编译器编译和处理器运行的时候。
编译期重排序的优势：
CPU计算的时候要访问值，如果常常利用到寄存器中已有的值就不用去内存读取了，比如下边的1就没有2的性能好。
------<1>------
int a = 1;
int b = 1;
a = a + 1;
b = b +1;
------<2>------
int a = 1;
a = a + 1; // a可能在寄存器中
int b = 1;
b = b +1; // b可能在寄存器中
---------------

处理器重排序的优势：
CPU使用了流水线技术，它可分为多个功能单元（如获取、解码、运算和结果）；
对于每个指令也分为多个步骤，涉及多个功能单元，CPU将多条指令功能单元相同或类似的步骤通过重排序连接执行来减少流水线中断的情况。


指令重排并不会影响单线程的顺序，它影响的是多线程并发执行的顺序性。
```
* 特性
```
a.能够保证变量的可见性，通过内存屏障实现。
b.能够保证变量读/写指令前后指令的有序性，通过禁止重排序优化实现。
c.不能保证类似i++ 这种操作的原子性。

代码示例：
int x;
int y;
volatile boolean flag;

x = 2;    //语句1
y = 0;    //语句2
flag = true;    //语句3
x = 4;    //语句4
y = -1;    //语句5

由于flag为volatile变量，那么编译器和处理器在进行指令重排序时，不会将语句3放到语句1或语句2的前面，也不会将语句3放到语句4或语句5的后面，但是语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。
volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。

应用价值：
// 线程1
run(){
    context = loadContext();    //语句1
    inited = true;             //语句2
}
// 线程2
run(){
    while( !inited ){
        sleep()
    }
    doSomethingwithconfig(context);
}

在指令重排序时，语句2可能在语句1之前执行，导致出现线程1对context还未初始化，线程2已经对context操作的现象；
若inited变量使用volatile关键字修饰，则可避免。
```
# synchronized
```
使用 synchronized 能够简化并发模型；并随着JVM的升级，几乎不需要修改代码，就可以直接享受JVM在内置锁上的优化成果。
```
* 特性
```
原子性：
说的是对于多个操作的执行过程不会被任何因素打断。
可见性：
指多个线程访问一个资源时，该资源的状态、值信息等对于其他线程都是可见的。
有序性：
针对的是指令重排序，它保证了每个时刻都只有一个线程访问同步代码块，也就确定了线程执行同步代码块是分先后顺序的，保证了有序性。
可重入性：
当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁。通俗一点讲就是说一个线程拥有了锁仍然还可以重复申请锁。
```
* 底层实现
```
对象由以下三部分数据组成：
a. 对象头（object header）主要结构是由 Mark Word 和 Class Metadata Address 组成，
   其中 Mark Word 存储对象的hashCode、锁信息、分代年龄及GC标志等信息，Class Metadata Address是类型指针，指向对象的类元数据。
b. 实例数据存放类的属性数据信息。
c. 对齐填充仅是作为占位符存在的，因为JVM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是对象的大小必须是8字节的整数倍，不够时需要通过对齐填充来补全。

锁的类型和状态在对象头 Mark Word 中记录，在申请锁、锁升级等过程中JVM都需要读取对象的Mark Word数据。

Monitor：
每个对象都存在着一个monitor对象与之关联，而每一个锁都对应一个monitor对象，当一个monitor对象被某个线程持有后，它便处于锁定状态。
Monitor对象主要由以下几个关键属性：
a. _EntryList 表示竞争锁的线程集合。
b. _count 表示锁的计数器。
c. _owner 表示持有当前ObjectMonitor对象的线程。
d. _WaitSet 表示处于等待被唤醒状态的线程集合。

当多线程同时访问一段同步代码时，首先会进入_EntryList 集合，当线程获取到对象的monitor 后进入 _Owner 区域并把monitor中的owner变量设置为当前线程同时monitor中的计数器count加1，若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSe t集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。

```
* JVM优化点

* 锁状态
```
偏向锁：


```
* 自旋锁
```
实现：
当线程竞争[轻量级?]锁失败时，不直接阻塞自己，而是自旋一会（空等待，比如一个空的有限for循环），在自旋的同时重新竞争锁，如果自旋结束前获得了锁，那么锁获取成功；否则，自旋结束后阻塞自己。

意义：
通过自旋锁，可以避免线程在操作系统层面挂起，减少线程阻塞造成的线程切换。
对于粒度小，持有时间较短的锁，在操作系统层面挂起线程和恢复线程的代价太高，通过自旋的方式让线程不让出CPU，可以减少这种情况的发生。

缺点：
a. 若锁被其他线程长时间占用，一直不释放CPU，会带来许多的性能开销。
b. 如果线程多而处理器少，自旋也会造成不少无谓的浪费。
c. 自旋锁要占用CPU，如果是计算密集型任务，这一优化通常得不偿失。
```
> 使用-XX:-UseSpinning参数关闭自旋锁优化；-XX:PreBlockSpin参数修改默认的自旋次数。




可重入实现
