# 网络七层协议
* 第1层：物理层
```
机械、电子、定时接口通信信道上的原始比特流传输，将010101等比特数据转换为电流强弱来进行传输。
常见设备：网卡。
```
* 第2层：数据链路层
```
物理寻址，同时将原始比特流转换为逻辑传输线路。这一层提供错误检测与纠正，以确保数据传输的可靠性。
常见设备：交换机。
```
* 第3层：网络层
```
将网络地址翻译成对应的物理地址。控制子网的运行，入逻辑编制、分组传输、路由选择。
常见设备：路由器。
常用协议：IP协议。
```
* 第4层：传输层
```
传输层解决了传输质量的问题，控制流量、数据包分割等。
常用协议：TCP和UDP。

TCP是网络传输层协议，是一种面向连接的、可靠传输的、基于字节流的传输协议。
UDP也是网络传输层协议，是一种无连接的传输协议，提供面向事务的简单不可靠信息传送服务，传输速率相对较快，但不能保证数据可靠性。
```
* 第5层：会话层
```
不同机器上的用户之间建立及管理会话。
```
* 第6层：表示层
```
解决不同系统语法通信的问题，加解密、转换翻译、压缩解压缩。
```
* 第7层：应用层
```
协议：HTTP。
```

# TCP协议
* 协议标识
```
SYN：同步序号，用于建立连接过程。
ACK：确认序号标志。
RST：重置连接标志。
URG：紧急指针标志。
PSH：push标志。
FIN：finish标志，用于释放链接。
```
* 三次握手
```
握手是为了建立连接，避免传输的数据包乱序问题，握手成功之后会建立一个全双工通信通道。
具体过程如下：
a. （第一次握手）客户端向服务端发起 SYN 请求，客户端进入 SYN_SENT 状态。
b. （第二次握手）服务端收到客户端发起的 SYN 请求后，内核会把该连接存储到半连接队列，并向客户端响应 SYN+ACK，服务端进入 SYN_RCVD 状态。
c. （第三次握手）客户端收到服务端的 SYN+ACK响应后，向服务端返回 ACK，客户端进入 ESTABLISED 状态。
d. 服务端收到客户端的 ACK 后，内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到全连接队列，等待进程调用 accept 函数时把连接取出来，服务端进入 ESTABLISED 状态。
```
* TCP 半连接队列和全连接队列
```
半连接队列，也称 SYN 队列；全连接队列，也称 accepet 队列。
-------------------------------------------------
查看当前 TCP 半连接队列的长度：
$ netstat -natp | grep SYN_RECV | wc -l
小技巧：如果一直是某个值，说明半连接队列的最大长度就是该值。
观察半连接队列溢出情况：
$ netstat -s | grep "SYNs to LISTEN"
-> 73 SYNs to LISTEN sockets dropped
输出数值是累计值，表示共有多少个 TCP 连接因为半连接队列溢出而被丢弃。
小技巧：隔几秒执行一次，如果有上升的趋势，说明当前存在半连接队列溢出的现象。

syncookies 功能：
开启 syncookies 功能就可以在不使用 SYN 半连接队列的情况下成功建立连接，它也是防御 SYN 攻击的手段之一。
-------------------------------------------------
查看 TCP 全连接队列的大小：
$ ss -lnt
State     Recv-Q    Send-Q    Local Address:Port    Peer Address:Port              
LISTEN    0         128       *:22222               *:*

Recv-Q：当前全连接队列的大小。
Send-Q：当前全连接最大队列长度。

查看 TCP 全连接队列溢出情况：
$ date;netstat -s | grep overflowed
Mon Jun 21 15:25:08 CST 2021
    234 times the listen queue of a socket overflowed
输出数值是累计值，表示共有多少个 TCP 连接因为全连接队列溢出而被丢弃。
小技巧：隔几秒执行一次，如果有上升的趋势，说明当前存在全连接队列溢出的现象。

如何增大 TCP 全连接队列呢？
TCP 全连接队列足最大值取决于 somaxconn 和 backlog 之间的最小值。
```
* 为什么需要第三次握手?两次不可以吗？
```
三次握手是为了防止服务端突然收到已失效的连接发出的请求报文而重新建立无效的新连接。
比如，客户端发送的请求报文因网络出现滞留，直到连接释放后才到达服务器，若没有三次握手，服务端会认为是新连接请求，进而建立连接，这种连接其实是无效的。
```
* 三次握手中SYN Flood隐患以及其解决措施
```
起因：
服务端收到客户端的 SYN，回复 SYN-ACK 后未收到客户端的 ACK 确认，服务端会不断重试直至超时。

隐患：
恶意程序向服务器发送 SYN 数据报，然后下线，进而耗尽半连接队列，使正常连接无法进行。

防护措施：
半连接队列满后，通过 tcp_syncookies 参数会发 SYN Cookie，若为正常连接则客户端会回发 SYN Cookie，直接建立连接。
```
* 四次挥手
```
a. 客户端发送一个 FIN 请求，用来关闭客户端到服务端的数据传输，客户端进入FIN_WAIT_1状态。
b. 服务端收到客户端的 FIN 后，向客户端响应 ACK ，服务端进入 CLOSE_WAIT 状态。
c. 服务端发送一个 FIN 请求，用来关闭服务端到客户端的数据传输，服务端进入 LAST_ACK 状态。
d. 客户端收到服务端的 FIN 后，客户端进入 TIME_WAIT 状态，并响应一个 ACK 给服务端。
e. 服务端收到客户端的 ACK 后进入CLOSED状态。
```
* 为什么需要四次挥手？
```
TCP是全双工，发送方和接收方都需要 FIN报文和ACK报文。
```
* 什么情况下服务器会出现大量 CLOSE_WAIT 状态？
```
当大量客户端请求关闭Socket连接，而服务器又忙于读或写，没有及时关闭连接。
服务器一旦达到 CLOSE_WAIT 上限就会抛出too many open files异常，甚至有可能造成服务器崩溃。
```

# HTTP

# HTTPS
* 简述一下HTTPS协议的数据传输流程
```
a. 浏览器将支持的加密算法信息发送给服务器。
b. 服务器选择一套浏览器支持的加密算法，将验证身份的信息以证书的形式回发给浏览器。
c. 浏览收到证书验证其合法性，并结合证书公钥加密信息发送给服务器。
d. 服务器使用私钥解密信息，验证哈希，加密相应消息回发浏览器。
e. 浏览器解密相应消息，并对消息进行验证。
```
